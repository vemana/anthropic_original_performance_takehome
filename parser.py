# A parser for a language that mimics the machine of this problem
# Generated by instructions: https://gemini.google.com/share/ea1522ee06a1

import re
import sys
import traceback
from dataclasses import dataclass
from typing import Any, Callable, Generic, Optional, TypeVar, Union

T = TypeVar("T")

# --- Parser Combinator Framework ---

@dataclass
class ParseResult(Generic[T]):
    value: T
    next_index: int

class Parser(Generic[T]):
    def __init__(self, parse_fn: Callable[[str, int], Optional[ParseResult[T]]]):
        self._parse = parse_fn

    def parse(self, text: str, index: int = 0) -> Optional[ParseResult[T]]:
        return self._parse(text, index)

    def map(self, fn: Callable[[T], Any]) -> "Parser":
        def new_fn(text: str, index: int):
            res = self.parse(text, index)
            return ParseResult(fn(res.value), res.next_index) if res else None
        return Parser(new_fn)

    def star(self) -> "Parser[list[T]]":
        def new_fn(text: str, index: int):
            results = []
            curr = index
            while True:
                res = self.parse(text, curr)
                if not res or res.next_index <= curr: break
                results.append(res.value)
                curr = res.next_index
            return ParseResult(results, curr)
        return Parser(new_fn)

    def plus(self) -> "Parser[list[T]]":
        def new_fn(text: str, index: int):
            res = self.parse(text, index)
            if not res: return None
            tail = self.star().parse(text, res.next_index)
            return ParseResult([res.value] + tail.value, tail.next_index)
        return Parser(new_fn)

    def opt(self) -> "Parser[Optional[T]]":
        def new_fn(text: str, index: int):
            res = self.parse(text, index)
            return res if res else ParseResult(None, index)
        return Parser(new_fn)

    def __or__(self, other: "Parser") -> "Parser":
        def new_fn(text: str, index: int):
            return self.parse(text, index) or other.parse(text, index)
        return Parser(new_fn)

def seq(*parsers: Parser) -> Parser[list[Any]]:
    def new_fn(text: str, index: int):
        results = []
        curr = index
        for p in parsers:
            res = p.parse(text, curr)
            if res is None: return None
            results.append(res.value)
            curr = res.next_index
        return ParseResult(results, curr)
    return Parser(new_fn)

def regex(pattern: str) -> Parser[str]:
    exp = re.compile(pattern)
    def new_fn(text: str, index: int):
        match = exp.match(text, index)
        return ParseResult(match.group(), match.end()) if match else None
    return Parser(new_fn)

def lit(string: str) -> Parser[str]:
    def new_fn(text: str, index: int):
        if text.startswith(string, index):
            return ParseResult(string, index + len(string))
        return None
    return Parser(new_fn)

def lazy(fn: Callable[[], Parser]) -> Parser:
    p = None
    def new_fn(text: str, index: int):
        nonlocal p
        if p is None: p = fn()
        return p.parse(text, index)
    return Parser(new_fn)

# --- Grammar Dataclasses (Sum Types via Inheritance) ---

class ValueExpr: pass

class VarOrConstant: pass

class IntConstantExpr(ValueExpr, VarOrConstant): pass

@dataclass
class NumberStringHex(IntConstantExpr): value: str

@dataclass
class NumberString(IntConstantExpr): value: str

class GlobalStmt: pass
class ThreadLocalStmt: pass

class VariableDeclarationStmt(GlobalStmt): pass

@dataclass
class VariableDeclaration(VariableDeclarationStmt):
    var_type: str
    name: str
    other_names: list[str]


@dataclass
class VariableDefinition(VariableDeclarationStmt):
    var_type: str
    name: str
    value: ValueExpr

class AssignmentStmt(GlobalStmt, ThreadLocalStmt): pass

class PauseStmt(ThreadLocalStmt): pass

@dataclass
class LoadVariable(AssignmentStmt):
    name: str
    value: ValueExpr

@dataclass
class StoreMemory(AssignmentStmt):
    name: str
    value: ValueExpr

@dataclass
class DerefIndividualWords(ValueExpr): name: str

@dataclass
class DerefVariable(ValueExpr): name: str

@dataclass
class DerefConstant(ValueExpr): expr: IntConstantExpr

@dataclass
class Variable(ValueExpr, VarOrConstant):
    name: str
    index: Optional[IntConstantExpr]

@dataclass
class BinOpExpr(ValueExpr):
    left: VarOrConstant
    op: str
    right: VarOrConstant

@dataclass
class MultAddExpr(ValueExpr):
    factor1: str
    factor2: VarOrConstant
    add: VarOrConstant

@dataclass
class CondExpr:
    left: Union[str, IntConstantExpr]
    op: str
    right: Union[str, IntConstantExpr]

@dataclass
class SelectExpr(ValueExpr):
    cond: Union[str, CondExpr]
    if_true: VarOrConstant
    if_false: VarOrConstant

@dataclass
class EndGlobalStmt: pass

@dataclass
class GlobalProgram:
    stmts: list[GlobalStmt]
    end: EndGlobalStmt

@dataclass
class ThreadLocalVariableStmt(ThreadLocalStmt):
    decl: VariableDeclarationStmt

@dataclass
class ThreadLocalProgram:
    stmts: list[ThreadLocalStmt]

@dataclass
class Program:
    global_prog: GlobalProgram
    thread_prog: ThreadLocalProgram

# --- Parser Definitions ---

space = regex(r"[ ]+")
opt_space = regex(r"[ ]*")
nl = regex(r"[ ]*(#[^\n]*)?\n[ ]*")
digit = regex(r"[0-9]")
hex_digit = regex(r"[0-9A-Fa-f]")
small = regex(r"[a-z]")
letter = regex(r"[a-zA-Z0-9_]")
minus = lit('-')
operator = lit('*') | lit('+') | lit('^') | lit('>>') | lit('-') | lit('<<') | lit('%') | lit('==')
cmp_operator = lit('<') | lit('==')

lit_eq = seq(opt_space, lit('='), opt_space)
lit_qu = seq(opt_space, lit('?'), opt_space)
lit_op = seq(opt_space, operator, opt_space).map(lambda x: x[1].strip())
lit_cmp_op = seq(opt_space, cmp_operator, opt_space).map(lambda x: x[1].strip())
lit_comma = seq(opt_space, lit(','), opt_space)
lit_colon = seq(opt_space, lit(':'), opt_space)
lit_plus = seq(opt_space, lit('+'), opt_space)
lit_mult = seq(opt_space, lit('*'), opt_space)

variable_name = seq(small, letter.star()).map(lambda x: x[0] + "".join(x[1]))

int_constant_expr = (
    seq(lit('0x'), hex_digit.plus()).map(lambda x: NumberStringHex("0x" + "".join(x[1])))
    | seq(minus.opt(), digit.plus()).map(lambda x: NumberString(("" if x[0] is None else x[0]) + "".join(x[1])))
)

var_or_const = variable_name | int_constant_expr

cond_expr = (
    seq(var_or_const, lit_cmp_op, var_or_const).map(lambda x: CondExpr(x[0], x[1], x[2]))
    | variable_name
)

select_expr = seq(cond_expr, lit_qu, var_or_const, lit_colon, var_or_const).map(
    lambda x: SelectExpr(x[0], x[2], x[4])
)

bin_op_expr = seq(var_or_const, lit_op, var_or_const).map(lambda x: BinOpExpr(x[0], x[1], x[2]))

mult_add_expr = seq(variable_name, lit_mult, var_or_const, lit_plus, var_or_const).map(
    lambda x: MultAddExpr(x[0], x[2], x[4])
)

value_expr = lazy(lambda: (
    select_expr
    | mult_add_expr
    | seq(lit('@'), variable_name, lit('['), lit(']')).map(lambda x: DerefIndividualWords(x[1]))
    | seq(lit('@'), variable_name).map(lambda x: DerefVariable(x[1]))
    | seq(lit('@'), int_constant_expr).map(lambda x: DerefConstant(x[1]))
    | bin_op_expr
    | seq(variable_name, seq(lit('['), int_constant_expr, lit(']').opt()).opt()).map(
        lambda x: Variable(x[0], x[1][1] if x[1] else None)
    )
    | int_constant_expr
))

variable_type = lit('register[]') | lit('register')

variable_declaration_stmt = (
    seq(variable_type, space, variable_name, seq(lit_comma, variable_name).star(), nl.plus()).map(
        lambda x: VariableDeclaration(x[0], x[2], [v[1] for v in x[3]])
    )
    | seq(variable_type, space, variable_name, lit_eq, value_expr, nl.plus()).map(
        lambda x: VariableDefinition(x[0], x[2], x[4])
    )
)

assignment_stmt = (
    seq(variable_name, lit_eq, value_expr, nl.plus()).map(lambda x: LoadVariable(x[0], x[2]))
    | seq(lit('@'), variable_name, lit_eq, value_expr, nl.plus()).map(lambda x: StoreMemory(x[1], x[3]))
)

pause_stmt = seq(lit('pause'), nl.plus()).map(lambda x: PauseStmt())

global_stmt = variable_declaration_stmt | assignment_stmt | pause_stmt

end_global_stmt = seq(lit('end global'), nl.plus()).map(lambda _: EndGlobalStmt())

global_program = seq(global_stmt.star(), end_global_stmt).map(lambda x: GlobalProgram(x[0], x[1]))

thread_local_variable_stmt = seq(lit('thread'), space, variable_declaration_stmt).map(
    lambda x: ThreadLocalVariableStmt(x[2])
)


thread_local_stmt = thread_local_variable_stmt | assignment_stmt | pause_stmt

thread_local_program = thread_local_stmt.star().map(ThreadLocalProgram)

program = seq(nl.star(), global_program, thread_local_program).map(
    lambda x: Program(x[1], x[2])
)

# --- Runner ---

def run_parser(p: Parser, text: str):
    try:
        result = p.parse(text, 0)
        if result:
            print("--- PARSE SUCCESS ---")
            print(result.value)
            # Verification of inheritance
            if isinstance(result.value, Program):
                gs = result.value.global_prog.stmts[0]
                print(f"Global Stmt is GlobalStmt: {isinstance(gs, GlobalStmt)}")
                ts = result.value.thread_prog.stmts[0]
                print(f"Thread Stmt is ThreadLocalStmt: {isinstance(ts, ThreadLocalStmt)}")
            unmatched = text[result.next_index:]
            if unmatched:
                print(f"\n--- UNMATCHED CONTENT ---\n{unmatched[:100]}...")
            else:
                print("\n--- FULLY PARSED ---")
        else:
            print("--- PARSE FAILED (No match found) ---")
            print(f"Unmatched at start: {text[:100]}...")
    except Exception:
        traceback.print_exc()
        print(f"\n--- UNMATCHED CONTENT ---\n{text[:100]}...")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        with open(sys.argv[1], "r") as f:
            content = f.read()
        run_parser(program, content)
    else:
        sample_content = """
register x, y
register[] arr = 0x100
x = @y
@ptr = x + 5
end global

thread register z
a = @b[]
a = @b
a = b * c
a = b * c + 2
@out = z * 2 + 1
z = x < y ? x : y
"""
        run_parser(program, sample_content)
